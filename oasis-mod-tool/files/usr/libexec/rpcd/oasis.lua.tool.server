#!/usr/bin/env lua

--[[

# Oasis Local Tool (OLT) Server (Lua Script Ver)
 This server script is based on concepts inspired by the Model Context Protocol and Agents.json.
 By leveraging UBUS, an integral part of the OpenWrt ecosystem, the client and server can cooperate
 to allow the AI to access the tools it provides.
 On OpenWrt systems with Oasis and oasis-mod-tool installed, third-party developers can easily expose
 tools to the AI by simply downloading server scripts.

# Rules for defining tools in the local tool server
    - Rule 1. 
        If a tool requires arguments, you must specify a type string for each argument.

        Reference:
        1. string type  ---> "a_string"
        TODO: Investigate data type specifications other than "a_string" and add them here. 

    - Rule 2. 
        The table returned by server.response must be an associative array (key-value pairs).

        Example: 
        server.response({reply = "Hello Tool Client!"})

# Note
 This script is loaded by the `rpcd` module and registered with `ubusd` as a UBUS object.  

# Important
 Please avoid defining global functions in ubus server scripts.
 For AI tool scripts used in Oasis (like this one), write your logic using server.tool.
 If you need to create custom functions, put them inside the call field of the table that’s passed as the second argument to server.tool.
 The same rule applies when using require to load external libraries—make sure to call require inside the call field too.

 About rpcd lua plugin:
 https://github.com/openwrt/luci/blob/37ea60da580490a4d8178134297152661f25151d/applications/luci-app-example/root/usr/libexec/rpcd/luci.example
]]

local server = require("oasis.local.tool.server")

server.tool("get_ifname_list", {
    tool_desc = "Get the list of all network interface names.",
    call = function()
        local res_tbl = {}
        local index = 1

        -- Get all network interface names from /sys/class/net.
        local handle = io.popen("ls /sys/class/net")
        if handle then
            for line in handle:lines() do
                local key = "ifname" .. index
                res_tbl[key] = line
                index = index + 1
            end
            handle:close()
        end

        return server.response(res_tbl)
    end
})

server.tool("get_lan_ipaddr", {
    tool_desc = "Get the LAN IP Address.",
    call = function()
        local util = require("luci.util")
        local ip = util.trim(util.exec("uci get network.lan.ipaddr 2>/dev/null"))
        local res = server.response({lan_ipaddr = ip ~= "" and ip or nil})
        return res
    end
})

server.tool("get_wan_status", {
    tool_desc = "Get the WAN Status.",
    call = function()
        local util = require("luci.util")
        local json = util.exec("ubus call network.interface.wan status 2>/dev/null")
        local wan_status = require("luci.jsonc").parse(json)
        local res = server.response({
            up = wan_status and wan_status.up or false,
            ipv4_address = wan_status and wan_status['ipv4-address'] and wan_status['ipv4-address'][1] and wan_status['ipv4-address'][1].address or nil
        })
        return res
    end
})

server.tool("get_connected_clients", {
    tool_desc = "Get connected clients (STAs).",
    call = function()
        local util = require("luci.util")
        local leases = {}
        local json = util.exec("ubus call dhcp ipv4leases 2>/dev/null")
        local parsed = require("luci.jsonc").parse(json)
        if parsed and parsed.leases then
            for _, lease in ipairs(parsed.leases) do
                table.insert(leases, {
                    ip = lease.ip,
                    mac = lease.mac,
                    hostname = lease.hostname
                })
            end
        end

        local arp = util.exec("cat /proc/net/arp 2>/dev/null")
        for line in arp:gmatch("[^\r\n]+") do
            if not line:match("IP address") then
                local ip, _, _, mac = line:match("([^%s]+)%s+[^%s]+%s+[^%s]+%s+([^%s]+)")
                if ip and mac then
                    local found = false
                    for _, lease in ipairs(leases) do
                        if lease.ip == ip then
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(leases, {ip = ip, mac = mac})
                    end
                end
            end
        end

        local res = server.response({clients = leases})

        return res
    end
})

server.tool("get_system_load", {
    tool_desc = "Get System Info Load (uptime/meminfo)",
    call = function()
        local util = require("luci.util")
        local uptime_info = util.exec("uptime")
        local meminfo = util.exec("cat /proc/meminfo")
        local mem_total = meminfo:match("MemTotal:%s+(%d+)")
        local mem_free = meminfo:match("MemFree:%s+(%d+)")
        local res =  server.response({
            uptime = util.trim(uptime_info),
            mem_total_kb = tonumber(mem_total),
            mem_free_kb = tonumber(mem_free)
        })
        return res
    end
})

server.tool("get_storage_usage", {
    tool_desc = "Get the storage usage.",
    call = function()
        local util = require("luci.util")
        local df = util.exec("df -h / 2>/dev/null | tail -n 1")
        local size, used, avail, usep = df:match("%S+%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)")
        local res = server.response({
            size = size,
            used = used,
            available = avail,
            usage_percent = usep
        })
        return res
    end
})

server.tool("get_cpu_temp", {
    tool_desc = "Get the cpu temperature.",
    call = function()
        local util = require("luci.util")
        local temp = util.exec("cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null")
        local temp_c = tonumber(temp) and tonumber(temp) / 1000 or nil
        local res = server.response({cpu_temp_c = temp_c})
        return res
    end
})

server.run(arg)